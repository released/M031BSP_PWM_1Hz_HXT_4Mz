; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.CKO_Test||, CODE, READONLY, ALIGN=1

                  CKO_Test PROC
;;;87     
;;;88     void CKO_Test(void)
000000  b510              PUSH     {r4,lr}
;;;89     {
;;;90     	uint8_t DirectOutput = 1;
000002  2201              MOVS     r2,#1
;;;91     	/*
;;;92     		CKO frequency = (Clock source frequency) / 2^(u32ClkDiv + 1)
;;;93     	*/
;;;94     //    CLK_EnableCKO(CLK_CLKSEL1_CLKOSEL_HXT, 0, DirectOutput);
;;;95     //    CLK_EnableCKO(CLK_CLKSEL1_CLKOSEL_HIRC, 0, DirectOutput);	
;;;96     //    CLK_EnableCKO(CLK_CLKSEL1_CLKOSEL_PLL, CKO_FREQ_750K, 0);	
;;;97     //    CLK_EnableCKO(CLK_CLKSEL1_CLKOSEL_PLL, CKO_FREQ_6M, DirectOutput);	
;;;98     //    CLK_EnableCKO(CLK_CLKSEL1_CLKOSEL_PLL, CKO_FREQ_24M, DirectOutput);	
;;;99         CLK_EnableCKO(CLK_CLKSEL1_CLKOSEL_HCLK, CKO_FREQ_6M, DirectOutput);	
000004  2102              MOVS     r1,#2
000006  2020              MOVS     r0,#0x20
000008  f7fffffe          BL       CLK_EnableCKO
;;;100    }
00000c  bd10              POP      {r4,pc}
;;;101    
                          ENDP


                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;171    
;;;172    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;173    {
;;;174        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  0391              LSLS     r1,r2,#14
000006  4802              LDR      r0,|L2.16|
000008  f7fffffe          BL       GPIO_SetMode
;;;175    }
00000c  bd10              POP      {r4,pc}
;;;176    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40004040

                          AREA ||i.PWM0_Init||, CODE, READONLY, ALIGN=2

                  PWM0_Init PROC
;;;134    
;;;135    void PWM0_Init(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;136    {
;;;137        /*
;;;138          Configure PWM0 channel 0 init period and duty(down counter type).
;;;139          Period is PLL / (prescaler * (CNR + 1))
;;;140          Duty ratio = CMR / (CNR + 1)
;;;141          
;;;142          Period = 48 MHz / (1 * (199 + 1)) = 240000 Hz
;;;143          Duty ratio = 100 / (199 + 1) = 50%
;;;144        */
;;;145    	
;;;146        /* Set PWM0 timer clock prescaler */
;;;147        PWM_SET_PRESCALER(PWM0, PWM_CHANNEL, PWM_PSC - 1);
000002  4826              LDR      r0,|L3.156|
000004  4924              LDR      r1,|L3.152|
000006  61c1              STR      r1,[r0,#0x1c]
;;;148    	
;;;149        /* Set up counter type */
;;;150        PWM0->CTL1 &= ~PWM_CTL1_CNTTYPE0_Msk;
000008  6841              LDR      r1,[r0,#4]
00000a  0889              LSRS     r1,r1,#2
00000c  0089              LSLS     r1,r1,#2
00000e  6041              STR      r1,[r0,#4]
;;;151    
;;;152        /* Set PWM0 timer period */
;;;153        PWM_SET_CNR(PWM0, PWM_CHANNEL, PWM_CNR);
000010  4822              LDR      r0,|L3.156|
000012  4923              LDR      r1,|L3.160|
000014  3040              ADDS     r0,r0,#0x40
000016  6001              STR      r1,[r0,#0]
;;;154    	
;;;155        /* Set PWM0 timer duty */
;;;156        PWM_SET_CMR(PWM0, PWM_CHANNEL, PWM_CMR);	
000018  2100              MOVS     r1,#0
00001a  6201              STR      r1,[r0,#0x20]
;;;157    	
;;;158        /* Set output level at zero, compare up, period(center) and compare down of specified channel */
;;;159        PWM_SET_OUTPUT_LEVEL(PWM0, PWM_CHANNEL_MASK, PWM_OUTPUT_HIGH, PWM_OUTPUT_LOW, PWM_OUTPUT_NOTHING, PWM_OUTPUT_NOTHING);
00001c  4608              MOV      r0,r1
00001e  2401              MOVS     r4,#1
                  |L3.32|
000020  4621              MOV      r1,r4
000022  4081              LSLS     r1,r1,r0
000024  06c9              LSLS     r1,r1,#27
000026  d51a              BPL      |L3.94|
000028  491c              LDR      r1,|L3.156|
00002a  3180              ADDS     r1,r1,#0x80
00002c  6b0d              LDR      r5,[r1,#0x30]
00002e  2703              MOVS     r7,#3
000030  0042              LSLS     r2,r0,#1
000032  463b              MOV      r3,r7
000034  4093              LSLS     r3,r3,r2
000036  2602              MOVS     r6,#2
000038  439d              BICS     r5,r5,r3
00003a  4096              LSLS     r6,r6,r2
00003c  4335              ORRS     r5,r5,r6
00003e  630d              STR      r5,[r1,#0x30]
000040  6b0d              LDR      r5,[r1,#0x30]
000042  4616              MOV      r6,r2
000044  3610              ADDS     r6,r6,#0x10
000046  40b7              LSLS     r7,r7,r6
000048  43bd              BICS     r5,r5,r7
00004a  630d              STR      r5,[r1,#0x30]
00004c  6b4d              LDR      r5,[r1,#0x34]
00004e  439d              BICS     r5,r5,r3
000050  4623              MOV      r3,r4
000052  4093              LSLS     r3,r3,r2
000054  431d              ORRS     r5,r5,r3
000056  634d              STR      r5,[r1,#0x34]
000058  6b4a              LDR      r2,[r1,#0x34]
00005a  43ba              BICS     r2,r2,r7
00005c  634a              STR      r2,[r1,#0x34]
                  |L3.94|
00005e  1c40              ADDS     r0,r0,#1
000060  2806              CMP      r0,#6
000062  dbdd              BLT      |L3.32|
;;;160    	
;;;161        /* Enable output of PWM0 channel 0 */
;;;162        PWM_EnableOutput(PWM0, PWM_CHANNEL_MASK);
000064  4d0d              LDR      r5,|L3.156|
000066  2110              MOVS     r1,#0x10
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       PWM_EnableOutput
;;;163    	
;;;164    	PWM_Start(PWM0, PWM_CHANNEL_MASK);
00006e  2110              MOVS     r1,#0x10
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       PWM_Start
;;;165    	
;;;166    	set_flag(flag_reverse , ENABLE);
000076  490b              LDR      r1,|L3.164|
000078  7808              LDRB     r0,[r1,#0]  ; BitFlag
00007a  4320              ORRS     r0,r0,r4
;;;167    
;;;168    	CalNewDuty(PWM0, PWM_CHANNEL, 500, 1000);
00007c  4c07              LDR      r4,|L3.156|
00007e  7008              STRB     r0,[r1,#0]            ;166
000080  3440              ADDS     r4,r4,#0x40
000082  6820              LDR      r0,[r4,#0]
000084  21ff              MOVS     r1,#0xff
000086  31f5              ADDS     r1,r1,#0xf5
000088  1c40              ADDS     r0,r0,#1
00008a  4348              MULS     r0,r1,r0
00008c  0049              LSLS     r1,r1,#1
00008e  f7fffffe          BL       __aeabi_uidivmod
000092  6220              STR      r0,[r4,#0x20]
;;;169    	
;;;170    }
000094  bdf8              POP      {r3-r7,pc}
;;;171    
                          ENDP

000096  0000              DCW      0x0000
                  |L3.152|
                          DCD      0x000003e7
                  |L3.156|
                          DCD      0x40058000
                  |L3.160|
                          DCD      0x00000f9f
                  |L3.164|
                          DCD      ||.data||

                          AREA ||i.PWM_Change||, CODE, READONLY, ALIGN=2

                  PWM_Change PROC
;;;101    
;;;102    void PWM_Change(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;103    {
;;;104    
;;;105    	CalNewDuty(PWM0, PWM_CHANNEL, duty, 1000);
000002  4f0f              LDR      r7,|L4.64|
000004  6838              LDR      r0,[r7,#0]
000006  4d0f              LDR      r5,|L4.68|
000008  267d              MOVS     r6,#0x7d
00000a  886c              LDRH     r4,[r5,#2]  ; duty
00000c  1c40              ADDS     r0,r0,#1
00000e  00f6              LSLS     r6,r6,#3
000010  4360              MULS     r0,r4,r0
000012  4631              MOV      r1,r6
000014  f7fffffe          BL       __aeabi_uidivmod
000018  6238              STR      r0,[r7,#0x20]
;;;106    
;;;107    	if (is_flag_set(flag_reverse))
00001a  7828              LDRB     r0,[r5,#0]  ; BitFlag
00001c  07c1              LSLS     r1,r0,#31
00001e  d001              BEQ      |L4.36|
000020  1c64              ADDS     r4,r4,#1
;;;108    	{
;;;109    		duty++;	
000022  e000              B        |L4.38|
                  |L4.36|
000024  1e64              SUBS     r4,r4,#1
                  |L4.38|
;;;110    	}
;;;111    	else
;;;112    	{
;;;113    		duty--;
;;;114    	}
;;;115    
;;;116    	if (duty == 1000)
000026  b2a1              UXTH     r1,r4
000028  806c              STRH     r4,[r5,#2]            ;113
00002a  42b1              CMP      r1,r6
00002c  d102              BNE      |L4.52|
;;;117    	{
;;;118    		set_flag(flag_reverse , DISABLE);				
00002e  0840              LSRS     r0,r0,#1
000030  0040              LSLS     r0,r0,#1
000032  e003              B        |L4.60|
                  |L4.52|
;;;119    	}
;;;120    	else if (duty == 0)
000034  2900              CMP      r1,#0
000036  d102              BNE      |L4.62|
;;;121    	{
;;;122    		set_flag(flag_reverse , ENABLE);
000038  2101              MOVS     r1,#1
00003a  4308              ORRS     r0,r0,r1
                  |L4.60|
00003c  7028              STRB     r0,[r5,#0]            ;118
                  |L4.62|
;;;123    	}
;;;124    	
;;;125    }
00003e  bdf8              POP      {r3-r7,pc}
;;;126    
                          ENDP

                  |L4.64|
                          DCD      0x40058040
                  |L4.68|
                          DCD      ||.data||

                          AREA ||i.PWM_Set_Duty||, CODE, READONLY, ALIGN=1

                  PWM_Set_Duty PROC
;;;126    
;;;127    void PWM_Set_Duty(PWM_T *pwm,uint32_t u32ChannelNum,uint32_t u32DutyCycle,uint32_t u32CycleResolution)		// 1 ~ 1000 , 0.1 % to 100%
000000  b570              PUSH     {r4-r6,lr}
;;;128    {
000002  4605              MOV      r5,r0
;;;129        uint32_t u32NewCMR = 0;
;;;130    	u32NewCMR = CalNewDutyCMR(pwm, u32ChannelNum, u32DutyCycle, u32CycleResolution);    
000004  0848              LSRS     r0,r1,#1
000006  00c0              LSLS     r0,r0,#3
000008  1940              ADDS     r0,r0,r5
00000a  6b00              LDR      r0,[r0,#0x30]
00000c  460c              MOV      r4,r1                 ;128
00000e  1c40              ADDS     r0,r0,#1
000010  4350              MULS     r0,r2,r0
000012  4619              MOV      r1,r3
000014  f7fffffe          BL       __aeabi_uidivmod
;;;131    	PWM_SET_CMR(pwm, u32ChannelNum, u32NewCMR);
000018  00a1              LSLS     r1,r4,#2
00001a  1949              ADDS     r1,r1,r5
00001c  6508              STR      r0,[r1,#0x50]
;;;132    }
00001e  bd70              POP      {r4-r6,pc}
;;;133    
                          ENDP


                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;258    
;;;259    void SYS_Init(void)
000000  b5f8              PUSH     {r3-r7,lr}
000002  2059              MOVS     r0,#0x59
000004  4c2a              LDR      r4,|L6.176|
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L6.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6021              STR      r1,[r4,#0]
00000e  6022              STR      r2,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L6.10|
;;;260    {
;;;261        /* Unlock protected registers */
;;;262        SYS_UnlockReg();
;;;263    
;;;264        GPIO_SetMode(PF, BIT2|BIT3, GPIO_MODE_INPUT);
000016  2200              MOVS     r2,#0
000018  210c              MOVS     r1,#0xc
00001a  4826              LDR      r0,|L6.180|
00001c  f7fffffe          BL       GPIO_SetMode
;;;265    
;;;266    	#if 1
;;;267    	CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk|CLK_PWRCTL_HXTEN_Msk);
000020  2005              MOVS     r0,#5
000022  f7fffffe          BL       CLK_EnableXtalRC
;;;268    	CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk|CLK_STATUS_HXTSTB_Msk);
000026  2011              MOVS     r0,#0x11
000028  f7fffffe          BL       CLK_WaitClockReady
;;;269    	#else
;;;270        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);	
;;;271        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;272    	#endif
;;;273    
;;;274        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;275    //    CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
;;;276        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HXT, CLK_CLKDIV0_HCLK(1));
00002c  2100              MOVS     r1,#0
00002e  4608              MOV      r0,r1
000030  f7fffffe          BL       CLK_SetHCLK
;;;277    
;;;278        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV1 | CLK_PCLKDIV_APB1DIV_DIV1);
000034  4820              LDR      r0,|L6.184|
000036  2500              MOVS     r5,#0
000038  6345              STR      r5,[r0,#0x34]
;;;279    
;;;280        /* Enable UART0 clock */
;;;281        CLK_EnableModuleClock(UART0_MODULE);
00003a  4e20              LDR      r6,|L6.188|
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       CLK_EnableModuleClock
;;;282        CLK_EnableModuleClock(TMR0_MODULE);
000042  4f1f              LDR      r7,|L6.192|
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       CLK_EnableModuleClock
;;;283        CLK_EnableModuleClock(TMR1_MODULE);
00004a  481e              LDR      r0,|L6.196|
00004c  f7fffffe          BL       CLK_EnableModuleClock
;;;284        CLK_EnableModuleClock(PWM0_MODULE);
000050  481d              LDR      r0,|L6.200|
000052  f7fffffe          BL       CLK_EnableModuleClock
;;;285    
;;;286        /* Switch UART0 clock source to HIRC */
;;;287        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
000056  2200              MOVS     r2,#0
000058  0679              LSLS     r1,r7,#25
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       CLK_SetModuleClock
;;;288    
;;;289        CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HXT, 0);
000060  2200              MOVS     r2,#0
000062  4611              MOV      r1,r2
000064  4638              MOV      r0,r7
000066  f7fffffe          BL       CLK_SetModuleClock
;;;290        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HXT, 0);
00006a  2200              MOVS     r2,#0
00006c  4611              MOV      r1,r2
00006e  4815              LDR      r0,|L6.196|
000070  f7fffffe          BL       CLK_SetModuleClock
;;;291        CLK_SetModuleClock(PWM0_MODULE, CLK_CLKSEL2_PWM0SEL_PCLK0, 0);
000074  2200              MOVS     r2,#0
000076  2101              MOVS     r1,#1
000078  4813              LDR      r0,|L6.200|
00007a  f7fffffe          BL       CLK_SetModuleClock
;;;292    
;;;293        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;294        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
00007e  06b0              LSLS     r0,r6,#26
000080  6bc1              LDR      r1,[r0,#0x3c]
000082  22ff              MOVS     r2,#0xff
000084  0412              LSLS     r2,r2,#16
000086  4391              BICS     r1,r1,r2
000088  2233              MOVS     r2,#0x33
00008a  0452              LSLS     r2,r2,#17
00008c  1889              ADDS     r1,r1,r2
00008e  63c1              STR      r1,[r0,#0x3c]
;;;295                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;296    
;;;297    #if defined (ENABLE_PWM_CH0)
;;;298    //    SYS->GPA_MFPL = (SYS->GPA_MFPL & (~SYS_GPA_MFPL_PA5MFP_Msk)) | SYS_GPA_MFPL_PA5MFP_PWM0_CH0;
;;;299        SYS->GPB_MFPL = (SYS->GPB_MFPL & (~SYS_GPB_MFPL_PB5MFP_Msk)) | SYS_GPB_MFPL_PB5MFP_PWM0_CH0;
;;;300    #elif defined (ENABLE_PWM_CH4)
;;;301        SYS->GPB_MFPL = (SYS->GPB_MFPL & (~SYS_GPB_MFPL_PB1MFP_Msk)) | SYS_GPB_MFPL_PB1MFP_PWM0_CH4;	
000090  6b81              LDR      r1,[r0,#0x38]
000092  22f0              MOVS     r2,#0xf0
000094  4391              BICS     r1,r1,r2
000096  31b0              ADDS     r1,r1,#0xb0
000098  6381              STR      r1,[r0,#0x38]
;;;302    #endif
;;;303    
;;;304    #if defined (ENABLE_CKO)
;;;305        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB14MFP_Msk)) | SYS_GPB_MFPH_PB14MFP_CLKO;
00009a  6bc1              LDR      r1,[r0,#0x3c]
00009c  0512              LSLS     r2,r2,#20
00009e  4391              BICS     r1,r1,r2
0000a0  2207              MOVS     r2,#7
0000a2  0652              LSLS     r2,r2,#25
0000a4  1889              ADDS     r1,r1,r2
0000a6  63c1              STR      r1,[r0,#0x3c]
;;;306    #endif
;;;307    	
;;;308        /* Update System Core Clock */
;;;309        SystemCoreClockUpdate();
0000a8  f7fffffe          BL       SystemCoreClockUpdate
0000ac  6025              STR      r5,[r4,#0]
;;;310    
;;;311        /* Lock protected registers */
;;;312        SYS_LockReg();
;;;313    }
0000ae  bdf8              POP      {r3-r7,pc}
;;;314    
                          ENDP

                  |L6.176|
                          DCD      0x40000100
                  |L6.180|
                          DCD      0x40004140
                  |L6.184|
                          DCD      0x40000200
                  |L6.188|
                          DCD      0x5f803d10
                  |L6.192|
                          DCD      0x5e800002
                  |L6.196|
                          DCD      0x5ec00003
                  |L6.200|
                          DCD      0xa2000010

                          AREA ||i.TIMER0_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_Init PROC
;;;231    
;;;232    void TIMER0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;233    {
;;;234        TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L7.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  2101              MOVS     r1,#1
000016  0749              LSLS     r1,r1,#29
000018  4308              ORRS     r0,r0,r1
00001a  6020              STR      r0,[r4,#0]
00001c  1548              ASRS     r0,r1,#21
00001e  4904              LDR      r1,|L7.48|
000020  6008              STR      r0,[r1,#0]
000022  6820              LDR      r0,[r4,#0]
000024  0589              LSLS     r1,r1,#22
000026  4308              ORRS     r0,r0,r1
000028  6020              STR      r0,[r4,#0]
;;;235        TIMER_EnableInt(TIMER0);
;;;236        NVIC_EnableIRQ(TMR0_IRQn);	
;;;237        TIMER_Start(TIMER0);
;;;238    }
00002a  bd10              POP      {r4,pc}
;;;239    
                          ENDP

                  |L7.44|
                          DCD      0x40050000
                  |L7.48|
                          DCD      0xe000e100

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;212    
;;;213    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;214    {
;;;215        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L8.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1508              ASRS     r0,r1,#20
00001c  4904              LDR      r1,|L8.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;216        TIMER_EnableInt(TIMER1);
;;;217        NVIC_EnableIRQ(TMR1_IRQn);	
;;;218        TIMER_Start(TIMER1);
;;;219    }
000028  bd10              POP      {r4,pc}
;;;220    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40050020
                  |L8.48|
                          DCD      0xe000e100

                          AREA ||i.TMR0_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;221    
;;;222    void TMR0_IRQHandler(void)
000000  4803              LDR      r0,|L9.16|
000002  6881              LDR      r1,[r0,#8]
000004  07c9              LSLS     r1,r1,#31
000006  0fc9              LSRS     r1,r1,#31
;;;223    {
000008  d001              BEQ      |L9.14|
00000a  2101              MOVS     r1,#1
00000c  6081              STR      r1,[r0,#8]
                  |L9.14|
;;;224        if(TIMER_GetIntFlag(TIMER0) == 1)
;;;225        {
;;;226            TIMER_ClearIntFlag(TIMER0);
;;;227    
;;;228        }
;;;229    }
00000e  4770              BX       lr
;;;230    
                          ENDP

                  |L9.16|
                          DCD      0x40050000

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;176    
;;;177    void TMR1_IRQHandler(void)
000000  4908              LDR      r1,|L10.36|
000002  6888              LDR      r0,[r1,#8]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
;;;178    {
000008  d00b              BEQ      |L10.34|
00000a  2001              MOVS     r0,#1
00000c  6088              STR      r0,[r1,#8]
;;;179    //	static uint32_t LOG = 0;
;;;180    	static uint16_t CNT = 0;
;;;181    
;;;182    //	static uint16_t CNT_PWM = 1;
;;;183    //	static uint16_t duty = 500;	// 1 ~ 1000 , 0.1 % to 100%
;;;184    
;;;185        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;186        {
;;;187            TIMER_ClearIntFlag(TIMER1);
;;;188    
;;;189    //		if (CNT_PWM++ == 500)
;;;190    //		{
;;;191    //			CNT_PWM = 1;
;;;192    			
;;;193    //			PWM_Set_Duty(PWM0, PWM_CHANNEL, duty, 1000);
;;;194    //			PWM_Change();
;;;195    			
;;;196    //			PB14 ^= 1;
;;;197    //		}		
;;;198    
;;;199    		if (CNT++ >= 1000)
00000e  4906              LDR      r1,|L10.40|
000010  8888              LDRH     r0,[r1,#4]  ; CNT
000012  1c42              ADDS     r2,r0,#1
000014  808a              STRH     r2,[r1,#4]
000016  227d              MOVS     r2,#0x7d
000018  00d2              LSLS     r2,r2,#3
00001a  4290              CMP      r0,r2
00001c  d301              BCC      |L10.34|
;;;200    		{		
;;;201    			CNT = 0;	
00001e  2000              MOVS     r0,#0
000020  8088              STRH     r0,[r1,#4]
                  |L10.34|
;;;202    
;;;203    			#if defined (ENABLE_LED)
;;;204    			PB14 ^= 1;
;;;205    			#endif
;;;206    			
;;;207    //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;208    		}
;;;209        }
;;;210    }
000022  4770              BX       lr
;;;211    
                          ENDP

                  |L10.36|
                          DCD      0x40050020
                  |L10.40|
                          DCD      ||.data||

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                  UART0_Init PROC
;;;239    
;;;240    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;241    {
;;;242        SYS_ResetModule(UART0_RST);
000002  4807              LDR      r0,|L11.32|
000004  f7fffffe          BL       SYS_ResetModule
;;;243    
;;;244        /* Configure UART0 and set UART0 baud rate */
;;;245        UART_Open(UART0, 115200);
000008  4c06              LDR      r4,|L11.36|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;246    
;;;247    	/* Set UART receive time-out */
;;;248    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;249    
;;;250    //	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
;;;251    //	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());	
;;;252    //	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
;;;253    //	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
;;;254    //	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
;;;255    //	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
;;;256    	
;;;257    }
00001c  bd10              POP      {r4,pc}
;;;258    
                          ENDP

00001e  0000              DCW      0x0000
                  |L11.32|
                          DCD      0x04000010
                  |L11.36|
                          DCD      0x40070000

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;322    
;;;323    int main()
000000  f7fffffe          BL       SYS_Init
;;;324    {
;;;325        SYS_Init();
;;;326    
;;;327        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;328    
;;;329    	#if defined (ENABLE_LED)
;;;330    	GPIO_Init();
;;;331    	#endif
;;;332    
;;;333    	PWM0_Init();
000008  f7fffffe          BL       PWM0_Init
;;;334    
;;;335    	TIMER0_Init();
00000c  f7fffffe          BL       TIMER0_Init
;;;336    	TIMER1_Init();
000010  f7fffffe          BL       TIMER1_Init
;;;337    
;;;338    	#if defined (ENABLE_CKO)
;;;339    	CKO_Test();
000014  f7fffffe          BL       CKO_Test
                  |L12.24|
;;;340    	#endif
;;;341    
;;;342        /* Got no where to go, just loop forever */
;;;343        while(1)
000018  e7fe              B        |L12.24|
;;;344        {
;;;345    
;;;346        }
;;;347    }
;;;348    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  BitFlag
000000  0000              DCB      0x00,0x00
                  duty
000002  01f4              DCW      0x01f4
                  ||CNT||
000004  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
